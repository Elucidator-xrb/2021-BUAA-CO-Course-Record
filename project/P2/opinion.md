# 高精度阶乘原理、优化
## 阶乘的（非递归）求法
递归地，阶乘可以被如下定义：
```c
long long factorial(int n) {
	if (n == 1 || n == 0) return 1;
	else return n * fatorial(n - 1);
}
```
这也是 计组教程 中提供的递归的例子。但是，这只是一个帮助理解递归的例子，千万不要认为阶乘只能用递归来求。实际上非递归解法或许会有更好地时间性能，以及能够更好的构建高精度的代码。如图：
```c
long long result = 1;
for (int i = 2; i <= n; i++) {
	result *= i;
}
```
## 高精度
众所周知，当你要处理一个长达1000位的数字的时候，`long long`也没招了，因为`long long`达不到需要的广度，`double`达不到需要的精度（毕竟是`1E-1000`）因此称此种离谱的又大精度要求又高的数字为高精度数（`Java`和`Python`和`matlab`有招，别管C语言了）这个时候你需要使用数组来维护这个高精度数，每一个数组元素来保存一个位置的数码，通过编程来模拟我们小学二年级就学过的竖式来实现各种算术功能。

经典的，要维护一个1000位十进制数，就开一个1000位的数组，每一个元素来存储一个十进制位。这里数组的头元素存储MSB（Most Significant Bit, 最高位）还是尾元素存储MSB都不是很重要。

如果你需要输出，就从MSB开始向LSB（最低位）遍历该数组，在你遍历到第一个非零数字之前，对所有的0都忽略，不做输出，在你遍历到第一个非零数字之后，对所有的数字，即使是0，都需要输出。存在一例外，即数组所有元素均为0时，最终输出0。不过，因为任何一个数的阶乘都不会是0，所以在本文档基本不予考虑此种例外。

### 高精度加
现在两个高精度数numA[N], numB[N]，相加之后存储到numC[N]。在处理每一位的时候，不仅需要考虑当前位置的两个加数，也需要考虑前一位可能产生的进位。这里提供两种方式

#### 统一进位
首先对于每一个 i = 0, 1, ..., n , numC[i] = numA[i] + numB[i]

然后，对于每一个 i = 0, 1, ..., n - 1 , 如果 numC[i] >= 10 , 则 numC[i+1] += 1, numC[i] -= 10

可以证明，这样两步之后每一位都在 [0, 10) 范围之内

|    | LSB |	|	|	|	| MSB |
|--|--|--|--|--|--|--|
|numA   | 1|	3|	5|	7|	9|	... |
|numB   | 2|	4|	6|	8|	0|	... |
|过程态 |  3|	7|	11|	15|	9|	... |
|numC   | 3|	7|	1|	6|	0|	...+1 |

#### 分散进位
维护一个初始值为 0 的进位变量 carry

对于每一个 `i = 0, 1, ..., n , numC[i] = numA[i] + numB[i] + carry` , 并且，如果 `numC[i] >= 10` ，则 `numC[i] -= 10, carry = 1`，否则 `carry = 0`

|  |LSB	|	|	|	|	|MSB| |
|--|--|--|--|--|--|--|
|numA|	1|	3|	5|	7|	9|	...|
|numB|	2|	4|	6|	8|	0|	...|
|carry|	0|	0|	1|	1|	0|	...|
|numC|	3|	7|	1|	6|	0|	...+1|

### 高精度乘低精度
现在我们接触到阶乘运算应用的比较多的高精度数乘低精度了。注意到高精度乘法其实分为高精度数相乘，和高精度数乘低精度数。

假设一个高精度数numA[N]，乘以一低精度数x，为了贴合阶乘这一实际问题，我们将结果覆盖的存储到numA[N]

#### 统一进位
首先对于每一个 i = 0, 1, ..., n , numA[i] = numA[i] * x

然后，对于每一个 i = 0, 1, ..., n - 1 , 如果 numA[i] >= 10 , 则 numA[i+1] += numA[i] / 10, numA[i] %= 10

#### 分散进位
维护一个初始值为 0 的进位变量 carry

对于每一个 i = 0, 1, ..., n , numA[i] = numA[i] * x + carry , 并且，如果 numA[i] >= 10 ，则 carry = numA[i] / 10, numA[i] %= 10 ，否则 carry = 0

这里和上面高精度加产生的一个比较值得注意的区别时计算进位的时候，从-=10改成了%=10，这是因为乘法可能产生高于1的进位

## 高精度阶乘（初级）
至此，我们基本上了解了如何算一个高精度数量级的阶乘。

维护一个高精度数组，其初状态为LSB为1，其他为0。

从2到n，使这个高精度数乘以它。

最后输出这个结果，完事。

但是出现一个问题：按照题目要求，1000位数，假设我们要求400的阶乘，（400! < 1E700）每一位数至少5条指令，那么总共的指令数已经超过了
$$ 1000 * 400 * 5 = 200000 $$
条指令，超时了。

当然，我们也应该意识到，这样的解决方案，在许多方面都产生了巨大的浪费。

一方面，用一个32位2进制的字来存储一个10进制位，这太屈才了；另一方面，当这个数字还比较小的时候，高位部分全部为0，但还是要处理他们，这太浪费了。

## 高精度阶乘的优化
因此，我们现在面临的问题不仅是能不能，还有快不快。我们需要优化我们的代码，以达到足够高的性能。

### 位数优化
刚才讲到过，寄存器有2^32的潜力，却栽在了1E1的空间里面。那么我们为什么不用一个数组元素来表示几个十进制位呢？

例如，2^32≈4E9，那么我们其实可以用每一个数组元素来存储0~1E9，总共9位数的信息。这样既节省时间，又节约空间。

这样固然好，但是同样存在问题：一个数组元素乘以那个低精度数之后，容易超过int的界限，放在MIPS，那就是指有可能结果的一部分会存储到hi寄存器。这不是我们希望的。

因此，我建议一个数组单元存储5位十进制位，即 0 <= num[i] <= 1E5 = 100000 。因为：当最坏情况：(1E5 - 1) * (1E4 - 1) 时（9999! >> 1E1000），结果不超过 1E9，我们时时刻刻都只需要对lo寄存器处理即可。当然其他位数也是可以的。（如图）

image.png

您也可以看作我们写的不是10进制高精度，而是100000进制的高精度。乘法和进位完全可以参照着10进制来写，但是输出的时候费点脑筋特殊判断一下位数不满5位的时候的0补位情况，即可。

## 乘法优化
假设我们每一次乘法都产生了进位，使得高精度数的最高非零单元产生了变化：我们约定，采用100000进制高精度表示，被乘数不超过10000

​ 第1次乘法：高精度数可能的最高的有效位数为1，该位被乘后数字为(100000 - 1) * (10000 - 1) < 1E9, 该位结果不超过 1E5 , 进位 carry < 1E9 / 1E5 = 1E4 产生进位只可能影响到至高第2位的数值，则第2次乘法，高精度数可能的最高的有效位数为2

​ 第k次乘法：高精度数可能的最高的有效位数为k，进位不超过2E4，该位被乘后加上进位的数字为(100000 - 1) * (10000 - 1) + 2E4 < 2E9 ，进位 carry < 2E4. 产生进位只可能影响到至高第k+1位的数值，则第k+1次乘法，高精度数可能的最高的有效位数为k+1

综上所述，对于第k次乘法，我们只需要计算前k+1位即可提前退出循环。形象地，可以称之为“剪枝”

纵然我们还有优化的空间，这已经帮我们省去了约1/2的时间复杂度。

## 乘数优化
前面的讨论中，我们经常认为这个低精度数取到了9999的最大值，但是实际情况中，低精度数往往比较小。例如，2~7总共6个数字相乘都只是5040。我们都需要了解一基本事实，那就是高精度乘低精度的时间代价是远远高于低精度乘低精度数的。

因此，我们不妨在取到了这个低精度数之后，先乘入到一个“缓存区域”，等到这个缓存区域足够大（以至于再乘入下一个低精度乘数之后就将超过9999的限制）的时候，再将他与高精度数相乘。（如图）

image(1).png


就我个人而言，完成前两部的优化之后，已经能够通过测试数据了。因此第三步优化并没有实际实现，在此只是提出一种可行的设想。


==========


# 高精度阶乘
撰写这道题的过程对笔者而言实际上是相当具有戏剧性的。而这道题的思路也有很多，这里主要分享下笔者的心路历程。

## 测试数据范围确定
由题，输出小于1000位，而450!恰为1001位，所以测试数据范围定为0~450.

## 原版十进制高精度
拿到这题，笔者一开始是直接用最原始的十进制高精度的写法写的，最后理所当然的T了，一测指令数高达260W条（输入为450，以下指令数对应输入均为450），颇有当年笔者写Hamilton回路的风范（

既然T了，自然得优化。

## 优化十进制高精度：存储空间优化，去零优化和乘数优化
### 存储空间优化
不难看出，我们用了一个32位寄存器来存一个十进制位，剩下28位直接就忽略了，这是对内存资源的极大浪费。而且在计算地址时也比较麻烦。联想到MIPS有sb和lb指令，笔者直接将一个十进制位存成一个字节，这样内存使用直接缩小为原来的1/4，且此时数组下标恰好就是相对地址，计算地址也比较方便。

### 去零优化
观察结果，可以发现大数阶乘结果末尾通常有一大串的0，而0乘以任何数也为0，更不可能产生进位，因此没必要浪费指令去计算0和乘数相乘，所以在进行乘法前，先把被乘数末尾的0去掉。而且实现起来也比较简单。前两个优化后的结果是260W条优化到180W条（没记错的话）。

### 乘数优化
这里的小标题直接借鉴了隔壁崔怿恺同学的帖子，因为整体思路相同，就是先把几个乘数乘起来，乘到与被乘数相乘将要溢出时，再进入乘法循环，这样可充分利用高精度的优势。优化后结果是180W条优化到60W条，可以看到，乘数优化对于十进制的高精度优化而言是相当大的。

然后优化不动了。。。。

## 另辟蹊径：大进制
优化不动，就得去找新算法，恰好笔者看到了崔佬的帖子，于是用100000进制+去零优化写了一份，最后结果是40W条，后来笔者发现，乘数最大到450，这样的话其实可以将进制再提高一个数量级变成1000000进制，然后将乘数限制在1000以内，由崔佬的帖子中的推算方法，此时相关结论依旧成立，优化后的指令数为31W。依旧高于20W。

而崔佬帖子中的乘数优化笔者实现了，但是优化程度较低（大概1W条），故最终没有采纳。

综上，可以得到一个小结论：乘数优化对低进制的优化要远高于对高进制的优化。

P.S. 传送门：崔怿恺：【Mars】高精度阶乘的原理和优化

## 无心插柳：0！特判
优化不成，笔者回到程序中，突然想到特殊值0，于是开始测试，发现进入了死循环！这有可能是T的一个原因，然后笔者将其更正以后上交。AC。（但是指令数实际上还是超了）

整体有效优化简化流程总结如下表：

|程序|	450！执行指令数|	评测结果|
|--|--|--|
|10进制无优化|	260W|	TLE|
|10进制+存储空间优化+去零优化|	180W|	TLE|
|10进制+存储空间优化+去零优化+乘数优化+特判|	60W|	AC|
|1000000进制+去零优化+特判|	31W|	AC|

## 总结
以上便是对这两题的思路总结与分享。

助教没下死手，（不然笔者还在TLE）。感谢助教不杀之恩（